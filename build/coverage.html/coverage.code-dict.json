{"/home/travis/build/npmtest/node-npmtest-stomp-client/test.js":"/* istanbul instrument in package npmtest_stomp_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stomp-client/lib.npmtest_stomp_client.js":"/* istanbul instrument in package npmtest_stomp_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_stomp_client = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_stomp_client = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-stomp-client/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-stomp-client && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_stomp_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_stomp_client\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_stomp_client.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_stomp_client.rollup.js'] =\n            local.assetsDict['/assets.npmtest_stomp_client.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_stomp_client.__dirname + '/lib.npmtest_stomp_client.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stomp-client/node_modules/stomp-client/lib/client.js":"var assert = require('assert');\nvar net = require('net');\nvar tls = require('tls');\nvar util = require('util');\nvar events = require('events');\nvar StompFrame = require('./frame').StompFrame;\nvar StompFrameEmitter = require('./parser').StompFrameEmitter;\n\n// Copied from modern node util._extend, because it didn't exist\n// in node 0.4.\nfunction _extend(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || typeof add !== 'object') return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\n// Inbound frame validators\nvar StompFrameCommands = {\n  '1.0': {\n    'CONNECTED': {\n      'headers': { 'session': { required: true } }\n    },\n    'MESSAGE' : {\n      'headers': {\n        'destination': { required: true },\n        'message-id': { required: true }\n      }\n    },\n    'ERROR': {},\n    'RECEIPT': {}\n  },\n  '1.1': {\n    'CONNECTED': {\n      'headers': { 'session': { required: true } }\n    },\n    'MESSAGE' : {\n      'headers': {\n        'destination': { required: true },\n        'message-id': { required: true }\n      }\n    },\n    'ERROR': {},\n    'RECEIPT': {}\n  }\n};\n\nfunction StompClient(opts) {\n\n  var address, port, user, pass, protocolVersion, vhost, reconnectOpts, tlsOpts;\n\n  if(arguments.length !== 1 || typeof opts === 'string') {\n    address = opts;\n    port = arguments[1];\n    user = arguments[2];\n    pass = arguments[3];\n    protocolVersion = arguments[4];\n    vhost = arguments[5];\n    reconnectOpts = arguments[6];\n    tlsOpts = arguments[7];\n    if(tlsOpts === true) {\n      tlsOpts = {};\n    }\n  }\n  else {\n    address = opts.address || opts.host;\n    port = opts.port;\n    user = opts.user;\n    pass = opts.pass;\n    protocolVersion = opts.protocolVersion;\n    vhost = opts.vhost;\n    reconnectOpts = opts.reconnectOpts;\n    tlsOpts = opts.tls;\n    // If boolean then TLS options are mixed in with other options\n    if(tlsOpts === true) {\n      tlsOpts = opts;\n    }\n  }\n\n  events.EventEmitter.call(this);\n  this.user = (user || '');\n  this.pass = (pass || '');\n  this.address = (address || '127.0.0.1');\n  this.port = (port || 61613);\n  this.version = (protocolVersion || '1.0');\n  this.subscriptions = {};\n  assert(StompFrameCommands[this.version], 'STOMP version '+this.version+' is not supported');\n  this._stompFrameEmitter = new StompFrameEmitter(StompFrameCommands[this.version]);\n  this.vhost = vhost || null;\n  this.reconnectOpts = reconnectOpts || {};\n  this.tls = tlsOpts;\n  this._retryNumber = 0;\n  this._retryDelay = this.reconnectOpts.delay;\n  return this;\n}\n\nutil.inherits(StompClient, events.EventEmitter);\n\nStompClient.prototype.connect = function (connectedCallback, errorCallback) {\n  var self = this;\n\n  //reset this field.\n  delete this._disconnectCallback;\n\n  if (errorCallback) {\n    self.on('error', errorCallback);\n  }\n\n  var connectEvent;\n\n  if(this.tls) {\n    self.stream = tls.connect(self.port, self.address, this.tls);\n    connectEvent = 'secureConnect';\n  }\n  else {\n    self.stream = net.createConnection(self.port, self.address);\n    connectEvent = 'connect';\n  }\n\n  self.stream.on(connectEvent, self.onConnect.bind(this));\n\n  self.stream.on('error', function(err) {\n    process.nextTick(function() {\n      //clear all of the stomp frame emitter listeners - we don't need them, we've disconnected.\n      self._stompFrameEmitter.removeAllListeners();\n    });\n    if (self._retryNumber < self.reconnectOpts.retries) {\n      if (self._retryNumber === 0) {\n        //we're disconnected, but we're going to try and reconnect.\n        self.emit('reconnecting');\n      }\n      self._reconnectTimer = setTimeout(function() {\n        self.connect();\n      }, self._retryNumber++ * self.reconnectOpts.delay)\n    } else {\n      if (self._retryNumber === self.reconnectOpts.retries) {\n        err.message += ' [reconnect attempts reached]';\n        err.reconnectionFailed = true;\n      }\n      self.emit('error', err);\n    }\n  });\n\n  if (connectedCallback) {\n    self.on('connect', connectedCallback);\n  }\n\n  return this;\n};\n\nStompClient.prototype.disconnect = function (callback) {\n  var self = this;\n\n  //just a bit of housekeeping. Remove the no-longer-useful reconnect timer.\n  if (self._reconnectTimer) {\n    clearTimeout(self._reconnectTimer);\n  }\n\n  if (this.stream) {\n    //provide a default no-op function as the callback is optional\n    this._disconnectCallback = callback || function() {};\n\n    var frame = new StompFrame({\n      command: 'DISCONNECT'\n    }).send(this.stream);\n\n    process.nextTick(function() {\n      self.stream.end();\n    });\n  }\n\n  return this;\n};\n\nStompClient.prototype.onConnect = function() {\n\n  var self = this;\n\n  // First set up the frame parser\n  var frameEmitter = self._stompFrameEmitter;\n\n  self.stream.on('data', function(data) {\n    frameEmitter.handleData(data);\n  });\n\n  self.stream.on('end', function() {\n    if (self._disconnectCallback) {\n      self._disconnectCallback();\n    } else {\n      self.stream.emit('error', new Error('Server has gone away'));\n    }\n  });\n\n  frameEmitter.on('MESSAGE', function(frame) {\n    var subscribed = self.subscriptions[frame.headers.destination];\n    // .unsubscribe() deletes the subscribed callbacks from the subscriptions,\n    // but until that UNSUBSCRIBE message is processed, we might still get\n    // MESSAGE. Check to make sure we don't call .map() on null.\n    if (subscribed) {\n      subscribed.listeners.map(function(callback) {\n        callback(frame.body, frame.headers);\n      });\n    }\n    self.emit('message', frame.body, frame.headers);\n  });\n\n  frameEmitter.on('CONNECTED', function(frame) {\n    if (self._retryNumber > 0) {\n      //handle a reconnection differently to the initial connection.\n      self.emit('reconnect', frame.headers.session, self._retryNumber);\n      self._retryNumber = 0;\n    } else {\n      self.emit('connect', frame.headers.session);\n    }\n  });\n\n  frameEmitter.on('ERROR', function(frame) {\n    var er = new Error(frame.headers.message);\n    // frame.headers used to be passed as er, so put the headers on er object\n    _extend(er, frame.headers);\n    self.emit('error', er, frame.body);\n  });\n\n  frameEmitter.on('parseError', function(err) {\n    // XXX(sam) err should be an Error object to more easily track the\n    // point of error detection, but it isn't, so create one now.\n    var er = new Error(err.message);\n    if (err.details) {\n      er.details = err.details;\n    }\n    self.emit('error', er);\n    self.stream.destroy();\n  });\n\n  // Send the CONNECT frame\n  var headers = {\n    'login': self.user,\n    'passcode': self.pass\n  };\n\n  if(this.vhost && this.version === '1.1')\n    headers.host = this.vhost;\n\n  var frame = new StompFrame({\n    command: 'CONNECT',\n    headers: headers\n  }).send(self.stream);\n\n  //if we've just reconnected, we'll need to re-subscribe\n  for (var queue in self.subscriptions) {\n    new StompFrame({\n      command: 'SUBSCRIBE',\n      headers: self.subscriptions[queue].headers\n    }).send(self.stream);\n  }\n};\n\nStompClient.prototype.subscribe = function(queue, _headers, _callback) {\n  // Allow _headers or callback in any order, for backwards compat: so headers\n  // is whichever arg is not a function, callback is whatever is left over.\n  var callback;\n  if (typeof _headers === 'function') {\n    callback = _headers;\n    _headers = null;\n  }\n  if (typeof _callback === 'function') {\n    callback = _callback;\n    _callback = null;\n  }\n  // Error now, preventing errors thrown from inside the 'MESSAGE' event handler\n  assert(callback, 'callback is mandatory on subscribe');\n\n  var headers = _extend({}, _headers || _callback);\n  headers.destination = queue;\n  if (!(queue in this.subscriptions)) {\n    this.subscriptions[queue] = {\n      listeners: [],\n      headers: headers\n    };\n    new StompFrame({\n      command: 'SUBSCRIBE',\n      headers: headers\n    }).send(this.stream);\n  }\n  this.subscriptions[queue].listeners.push(callback);\n  return this;\n};\n\n// no need to pass a callback parameter as there is no acknowledgment for\n// successful UNSUBSCRIBE from the STOMP server\nStompClient.prototype.unsubscribe = function (queue, headers) {\n  headers = _extend({}, headers);\n  headers.destination = queue;\n  new StompFrame({\n    command: 'UNSUBSCRIBE',\n    headers: headers\n  }).send(this.stream);\n  delete this.subscriptions[queue];\n  return this;\n};\n\nStompClient.prototype.publish = function(queue, message, headers) {\n  headers = _extend({}, headers);\n  headers.destination = queue;\n  new StompFrame({\n    command: 'SEND',\n    headers: headers,\n    body: message\n  }).send(this.stream);\n  return this;\n};\n\nfunction sendAckNack(acknack, messageId, subscription, transaction) {\n  var headers = {\n    'message-id': messageId,\n    'subscription': subscription\n  };\n  if(transaction) {\n    headers['transaction'] = transaction;\n  }\n  new StompFrame({\n    command: acknack,\n    headers: headers\n  }).send(this.stream);\n}\n\nStompClient.prototype.ack = function(messageId, subscription, transaction) {\n  sendAckNack.call(this, 'ACK', messageId, subscription, transaction);\n  return this;\n};\n\nStompClient.prototype.nack = function(messageId, subscription, transaction) {\n  sendAckNack.call(this, 'NACK', messageId, subscription, transaction);\n  return this;\n};\n\nObject.defineProperty(StompClient.prototype, 'writable', {\n  get: function(){\n    return this.stream && this.stream.writable;\n  }\n});\n\nmodule.exports = StompClient;\nmodule.exports.StompClient = StompClient;\n\nmodule.exports.Errors = {\n  streamNotWritable: 15201\n};\n","/home/travis/build/npmtest/node-npmtest-stomp-client/node_modules/stomp-client/lib/frame.js":"function StompFrame(frame) {\n  if (frame === undefined) {\n    frame = {};\n  }\n  this.command = frame.command || '';\n  this.headers = frame.headers || {};\n  this.body = frame.body || '';\n  this.contentLength = -1;\n}\n\nStompFrame.prototype.toString = function() {\n  return JSON.stringify({\n    command: this.command,\n    headers: this.headers,\n    body: this.body\n  });\n};\n\nStompFrame.prototype.send = function(stream) {\n  // Avoid small writes, they get sent in their own tcp packet, which\n  // is not efficient (and v8 does fast string concat).\n  var frame = this.command + '\\n';\n  for (var key in this.headers) {\n    frame += key + ':' + this.headers[key] + '\\n';\n  }\n  if (this.body.length > 0) {\n    if (!this.headers.hasOwnProperty('suppress-content-length')) {\n      frame += 'content-length:' + Buffer.byteLength(this.body) + '\\n';\n    }\n  }\n  frame += '\\n';\n  if (this.body.length > 0) {\n    frame += this.body;\n  }\n  frame += '\\0';\n  if(frame)\n    stream.write(frame);\n};\n\nStompFrame.prototype.setCommand = function(command) {\n  this.command = command;\n};\n\nStompFrame.prototype.setHeader = function(key, value) {\n  this.headers[key] = value;\n  if (key.toLowerCase() === 'content-length') {\n    this.contentLength = parseInt(value);\n  }\n};\n\nStompFrame.prototype.appendToBody = function(data) {\n  this.body += data;\n};\n\nStompFrame.prototype.validate = function(frameConstruct) {\n  var frameHeaders = Object.keys(this.headers);\n\n  // Check validity of frame headers\n  for (var header in frameConstruct.headers) {\n    var headerConstruct = frameConstruct.headers[header];\n\n    // Check required (if specified)\n    if (headerConstruct.hasOwnProperty('required') && headerConstruct.required === true) {\n      if (frameHeaders.indexOf(header) === -1) {\n        return {\n          isValid: false,\n          message: 'Header \"' + header + '\" is required for '+this.command,\n          details: 'Frame: ' + this.toString()\n        };\n      }\n    }\n\n    // Check regex of header value (if specified)\n    if (headerConstruct.hasOwnProperty('regex') && frameHeaders.indexOf(header) > -1) {\n      if (!this.headers[header].match(headerConstruct.regex)) {\n        return {\n          isValid: false,\n          message: 'Header \"' + header + '\" has value \"' + this.headers[header] + '\" which does not match against the following regex: ' + headerConstruct.regex + ' (Frame: ' + this.toString() + ')'\n        };\n      }\n    }\n  }\n\n  return { isValid: true };\n};\n\nexports.StompFrame = StompFrame;\n","/home/travis/build/npmtest/node-npmtest-stomp-client/node_modules/stomp-client/lib/parser.js":"var util = require('util');\nvar events = require('events');\nvar StompFrame = require('./frame').StompFrame;\n\nvar ParserStates = {\n  COMMAND: 0,\n  HEADERS: 1,\n  BODY: 2,\n  ERROR: 3\n};\n\nfunction StompFrameEmitter(frameValidators) {\n  events.EventEmitter.call(this);\n  this.state = ParserStates.COMMAND;\n  this.frame = new StompFrame();\n  this.frames = [];\n  this.buffer = '';\n  this.frameValidators = frameValidators || {};\n  this.commands = Object.keys(this.frameValidators);\n}\n\nutil.inherits(StompFrameEmitter, events.EventEmitter);\n\nStompFrameEmitter.prototype.incrementState = function () {\n  if (this.state === ParserStates.BODY || this.state === ParserStates.ERROR) {\n    this.state = ParserStates.COMMAND;\n  } else {\n    this.state++;\n  }\n};\n\nStompFrameEmitter.prototype.handleData = function (data) {\n  this.buffer += data;\n  do {\n    if (this.state === ParserStates.COMMAND) {\n      this.parseCommand();\n    }\n    if (this.state === ParserStates.HEADERS) {\n      this.parseHeaders();\n    }\n    if (this.state === ParserStates.BODY) {\n      this.parseBody();\n    }\n    if (this.state === ParserStates.ERROR) {\n      this.parseError();\n    }\n  } while (this.state === ParserStates.COMMAND && this.hasLine());\n};\n\nStompFrameEmitter.prototype.hasLine = function () {\n  return (this.buffer.indexOf('\\n') > -1);\n};\n\nStompFrameEmitter.prototype.popLine = function () {\n  var index = this.buffer.indexOf('\\n');\n  var line = this.buffer.slice(0, index);\n  this.buffer = this.buffer.substr(index + 1);\n  return line;\n};\n\nStompFrameEmitter.prototype.error = function (err) {\n  this.emit('parseError', err);\n  this.state = ParserStates.ERROR;\n};\n\nStompFrameEmitter.prototype.parseCommand = function () {\n  while (this.hasLine()) {\n    var line = this.popLine();\n    if (line !== '') {\n      if (this.commands.indexOf(line) === -1) {\n        this.error({\n          message: 'No such command ',\n          details: 'Unrecognized Command \\'' + line + '\\''\n        });\n        break;\n      }\n      this.frame.setCommand(line);\n      this.incrementState();\n      break;\n    }\n  }\n};\n\nStompFrameEmitter.prototype.parseHeaders = function () {\n  while (this.hasLine()) {\n    var line = this.popLine();\n    if (line === '') {\n      this.incrementState();\n      break;\n    } else {\n      var kv = line.split(':');\n      if (kv.length < 2) {\n        this.error({\n          message: 'Error parsing header',\n          details: 'No \":\" in line \"' + line + '\"'\n        });\n        break;\n      }\n      this.frame.setHeader(kv[0], kv.slice(1).join(':'));\n    }\n  }\n};\n\nStompFrameEmitter.prototype.parseBody = function () {\n  var bufferBuffer = new Buffer(this.buffer);\n\n  if (this.frame.contentLength > -1) {\n    var remainingLength = this.frame.contentLength - this.frame.body.length;\n\n    if(remainingLength < bufferBuffer.length) {\n      this.frame.appendToBody(bufferBuffer.slice(0, remainingLength).toString());\n      this.buffer = bufferBuffer.slice(remainingLength, bufferBuffer.length).toString();\n\n      if (this.frame.contentLength === Buffer.byteLength(this.frame.body)) {\n        this.frame.contentLength = -1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  var index = this.buffer.indexOf('\\0');\n\n  if (index == -1) {\n    this.frame.appendToBody(this.buffer);\n    this.buffer = '';\n  } else {\n    // The end of the frame has been identified, finish creating it\n    this.frame.appendToBody(this.buffer.slice(0, index));\n\n    var frameValidation = this.getFrameValidation(this.frame.command);\n\n    if (frameValidation.isValid) {\n      // Emit the frame and reset\n      this.emit('frame', this.frame);             // Event emit to catch any frame emission\n      this.emit(this.frame.command, this.frame);  // Specific frame emission\n    } else {\n      this.emit('parseError', {\n        message: frameValidation.message,\n        details: frameValidation.details,\n      });\n    }\n\n    this.frame = new StompFrame();\n    this.incrementState();\n    this.buffer = this.buffer.substr(index + 1);\n  }\n};\n\nStompFrameEmitter.prototype.getFrameValidation = function (command) {\n  if (!this.frameValidators.hasOwnProperty(command)) {\n    this.emit('parseError', { message: 'No validator defined for ' + command });\n  } else {\n    return this.frame.validate(this.frameValidators[command]);\n  }\n};\n\nStompFrameEmitter.prototype.parseError = function () {\n  var index = this.buffer.indexOf('\\0');\n  if (index > -1) {\n    this.buffer = this.buffer.substr(index + 1);\n    this.incrementState();\n  } else {\n    this.buffer = \"\";\n  }\n};\n\nnew StompFrameEmitter();\n\nexports.StompFrameEmitter = StompFrameEmitter;\n","/home/travis/build/npmtest/node-npmtest-stomp-client/node_modules/stomp-client/lib/server.js":"var net = require('net');\nvar fs = require('fs');\nvar util = require('util');\nvar crypto = require('crypto');\nvar StompFrame = require('./frame').StompFrame;\nvar StompFrameEmitter = require('./parser').StompFrameEmitter;\n\n//var privateKey = fs.readFileSync('CA/newkeyopen.pem', 'ascii');\n//var certificate = fs.readFileSync('CA/newcert.pem', 'ascii');\n//var certificateAuthority = fs.readFileSync('CA/demoCA/private/cakey.pem', 'ascii');\n/*\nvar credentials = crypto.createCredentials({\n    key: privateKey,\n    cert: certificate,\n    ca: certificateAuthority,\n});\n*/\n\nvar StompClientCommands = ['CONNECT', 'SEND', 'SUBSCRIBE', 'UNSUBSCRIBE', 'BEGIN', 'COMMIT', 'ACK', 'ABORT', 'DISCONNECT'];\n\nfunction StompSubscription(stream, session, ack) {\n  this.ack = ack;\n  this.session = session;\n  this.stream = stream;\n}\n\nStompSubscription.prototype.send = function(stompFrame) {\n  stompFrame.send(this.stream);\n};\n\nfunction StompQueueManager() {\n  this.queues = {};\n  this.msgId = 0;\n  this.sessionId = 0;\n}\n\nStompQueueManager.prototype.generateMessageId = function() {\n  return this.msgId++;\n};\n\nStompQueueManager.prototype.generateSessionId = function() {\n  return this.sessionId++;\n};\n\nStompQueueManager.prototype.subscribe = function(queue, stream, session, ack) {\n  if (!(queue in this.queues)) {\n    this.queues[queue] = [];\n  }\n  this.queues[queue].push(new StompSubscription(stream, session, ack));\n};\n\nStompQueueManager.prototype.publish = function(queue, message) {\n  if (!(queue in this.queues)) {\n    throw new StompFrame({\n      command: 'ERROR',\n      headers: {\n        message: 'Queue does not exist'\n      },\n      body: 'Queue \"' + frame.headers.destination + '\" does not exist'\n    });\n  }\n  var message = new StompFrame({\n    command: 'MESSAGE',\n    headers: {\n      'destination': queue,\n      'message-id': this.generateMessageId(),\n    },\n    body: message,\n  });\n  this.queues[queue].map(function(subscription) {\n    subscription.send(message);\n  });\n};\n\nStompQueueManager.prototype.unsubscribe = function(queue, session) {\n  if (!(queue in this.queues)) {\n    throw new StompFrame({\n      command: 'ERROR',\n      headers: {\n        message: 'Queue does not exist'\n      },\n      body: 'Queue \"' + frame.headers.destination + '\" does not exist'\n    });\n  }\n  // TODO: Profile this\n  this.queues[queue] = this.queues[queue].filter(function(subscription) {\n    return (subscription.session != session);\n  });\n};\n\nfunction StompStreamHandler(stream, queueManager) {\n  var frameEmitter = new StompFrameEmitter(StompClientCommands);\n  var authenticated = false;\n  var sessionId = -1;\n  var subscriptions = [];\n  var transactions = {};\n\n  stream.on('data', function(data) {\n    frameEmitter.handleData(data);\n  });\n\n  stream.on('end', function() {\n    subscriptions.map(function(queue) {\n      queueManager.unsubscribe(queue, sessionId);\n    });\n    stream.end();\n  });\n\n  frameEmitter.on('frame', function(frame) {\n    if (!authenticated && frame.command != 'CONNECT') {\n      new StompFrame({\n        command: 'ERROR',\n        headers: {\n          message: 'Not connected'\n        },\n        body: 'You must first issue a CONNECT command'\n      }).send(stream);\n      return;\n    }\n    if (frame.command != 'CONNECT' && 'receipt' in frame.headers) {\n      new StompFrame({\n        command: 'RECEIPT',\n        headers: {\n          'receipt-id': frame.headers.receipt\n        }\n      }).send(stream);\n    }\n    try {\n      switch (frame.command) {\n      case 'CONNECT':\n        // TODO: Actual authentication\n        authenticated = true;\n        sessionId = queueManager.generateSessionId();\n        new StompFrame({\n          command: 'CONNECTED',\n          headers: {\n            session: sessionId\n          }\n        }).send(stream);\n        break;\n\n      case 'SUBSCRIBE':\n        queueManager.subscribe(frame.headers.destination, stream, sessionId, frame.headers.ack || \"auto\");\n        subscriptions.push(frame.headers.destination);\n        break;\n\n      case 'UNSUBSCRIBE':\n        queueManager.unsubscribe(frame.headers.destination, sessionId);\n        break;\n\n      case 'SEND':\n        queueManager.publish(frame.headers.destination, frame.body);\n        break;\n\n      case 'BEGIN':\n        if (frame.headers.transaction in transactions) {\n          throw new StompFrame({\n            command: 'ERROR',\n            headers: {\n              message: 'Transaction already exists'\n            },\n            body: 'Transaction \"' + frame.headers.transaction + '\" already exists'\n          });\n        }\n        transactions[frame.headers.transaction] = [];\n        break;\n\n      case 'COMMIT':\n        // TODO: Actually apply the transaction, this is just an abort\n        delete transactions[frame.headers.transaction];\n        break;\n\n      case 'ABORT':\n        delete transactions[frame.headers.transaction];\n        break;\n\n      case 'DISCONECT':\n        subscriptions.map(function(queue) {\n          queueManager.unsubscribe(queue, sessionId);\n        });\n        stream.end();\n        break;\n      }\n    } catch (e) {\n      e.send(stream);\n    }\n  });\n\n  frameEmitter.on('error', function(err) {\n    var response = new StompFrame();\n    response.setCommand('ERROR');\n    response.setHeader('message', err['message']);\n    if ('details' in err) {\n      response.appendToBody(err['details']);\n    }\n    response.send(stream);\n  });\n}\n\nfunction StompServer(port) {\n  this.port = port;\n  var queueManager = new StompQueueManager();\n  this.server = net.createServer(function(stream) {\n    stream.on('connect', function() {\n      console.log('Received Unsecured Connection');\n      new StompStreamHandler(stream, queueManager);\n    });\n  });\n}\n\nfunction SecureStompServer(port, credentials) {\n  StompServer.call(this);\n  var queueManager = new StompQueueManager();\n  this.port = port;\n  this.server = net.createServer(function(stream) {\n    stream.on('connect', function() {\n      console.log('Received Connection, securing');\n      stream.setSecure(credentials);\n    });\n    stream.on('secure', function() {\n      new StompStreamHandler(stream, queueManager);\n    });\n  });\n}\n\nutil.inherits(SecureStompServer, StompServer);\n\nStompServer.prototype.listen = function() {\n  this.server.listen(this.port, 'localhost');\n};\n\nStompServer.prototype.stop = function(port) {\n  this.server.close();\n};\n\n//new SecureStompServer(8124, credentials).listen();\nexports.createStompServer = function(port) {\n  return new StompServer(port);\n};\n"}